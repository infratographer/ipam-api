// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package testclient

import (
	"fmt"
	"io"
	"strconv"
	"time"

	"go.infratographer.com/x/gidx"
)

// An object with an ID.
// Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
type Node interface {
	IsNode()
	// The id of the object.
	GetID() gidx.PrefixedID
}

type Entity interface {
	IsEntity()
}

// Create a new ip address type node.
type CreateIPAddressInput struct {
	// The ip address.
	IP string `json:"ip"`
	// The ID for the node this is assigned to.
	NodeID gidx.PrefixedID `json:"nodeID"`
	// Owner ID of the node this is assigned to.
	NodeOwnerID gidx.PrefixedID `json:"nodeOwnerID"`
	// Reserve the IP without it being assigned.
	Reserved  *bool           `json:"reserved,omitempty"`
	IPBlockID gidx.PrefixedID `json:"ipBlockID"`
}

// Create a new ip block type node.
type CreateIPBlockInput struct {
	// The prefix of the ip block.
	Prefix string `json:"prefix"`
	// The ID for the location for this ip block.
	LocationID gidx.PrefixedID `json:"locationID"`
	// The ID for the parent of this ip block.
	ParentBlockID gidx.PrefixedID `json:"parentBlockID"`
	// Allow carving this block into smaller subnets.
	AllowAutoSubnet *bool `json:"allowAutoSubnet,omitempty"`
	// Allow automatically assigning IPs directly from this block.
	AllowAutoAllocate *bool           `json:"allowAutoAllocate,omitempty"`
	IPBlockTypeID     gidx.PrefixedID `json:"ipBlockTypeID"`
}

// Create a new ip block type node.
type CreateIPBlockTypeInput struct {
	// The name of the ip block type.
	Name string `json:"name"`
	// The ID for the owner for this ip block type.
	OwnerID gidx.PrefixedID `json:"ownerID"`
}

type IPAddress struct {
	// The ID of the IP Address.
	ID        gidx.PrefixedID `json:"id"`
	CreatedAt time.Time       `json:"createdAt"`
	UpdatedAt time.Time       `json:"updatedAt"`
	// The ip address.
	IP string `json:"ip"`
	// Reserve the IP without it being assigned.
	Reserved bool    `json:"reserved"`
	IPBlock  IPBlock `json:"ipBlock"`
}

func (IPAddress) IsNode() {}

// The id of the object.
func (this IPAddress) GetID() gidx.PrefixedID { return this.ID }

func (IPAddress) IsEntity() {}

// A connection to a list of items.
type IPAddressConnection struct {
	// A list of edges.
	Edges []*IPAddressEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createIPAddress mutation
type IPAddressCreatePayload struct {
	// Created ip block type
	IPAddress IPAddress `json:"ip_address"`
}

// Return response for deleteIPAddress mutation
type IPAddressDeletePayload struct {
	// Deleted ip block type
	DeletedID gidx.PrefixedID `json:"deletedID"`
}

// An edge in a connection.
type IPAddressEdge struct {
	// The item at the end of the edge.
	Node *IPAddress `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for IPAddress connections
type IPAddressOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order IPAddresses.
	Field IPAddressOrderField `json:"field"`
}

// Return response for updateIPAddress mutation
type IPAddressUpdatePayload struct {
	// Updated ip block type
	IPAddress IPAddress `json:"ip_address"`
}

// IPAddressWhereInput is used for filtering IPAddress objects.
// Input was generated by ent.
type IPAddressWhereInput struct {
	Not *IPAddressWhereInput   `json:"not,omitempty"`
	And []*IPAddressWhereInput `json:"and,omitempty"`
	Or  []*IPAddressWhereInput `json:"or,omitempty"`
	// id field predicates
	ID      *gidx.PrefixedID  `json:"id,omitempty"`
	IDNeq   *gidx.PrefixedID  `json:"idNEQ,omitempty"`
	IDIn    []gidx.PrefixedID `json:"idIn,omitempty"`
	IDNotIn []gidx.PrefixedID `json:"idNotIn,omitempty"`
	IDGt    *gidx.PrefixedID  `json:"idGT,omitempty"`
	IDGte   *gidx.PrefixedID  `json:"idGTE,omitempty"`
	IDLt    *gidx.PrefixedID  `json:"idLT,omitempty"`
	IDLte   *gidx.PrefixedID  `json:"idLTE,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE,omitempty"`
	// IP field predicates
	IP             *string  `json:"ip,omitempty"`
	IPNeq          *string  `json:"ipNEQ,omitempty"`
	IPIn           []string `json:"ipIn,omitempty"`
	IPNotIn        []string `json:"ipNotIn,omitempty"`
	IPGt           *string  `json:"ipGT,omitempty"`
	IPGte          *string  `json:"ipGTE,omitempty"`
	IPLt           *string  `json:"ipLT,omitempty"`
	IPLte          *string  `json:"ipLTE,omitempty"`
	IPContains     *string  `json:"ipContains,omitempty"`
	IPHasPrefix    *string  `json:"ipHasPrefix,omitempty"`
	IPHasSuffix    *string  `json:"ipHasSuffix,omitempty"`
	IPEqualFold    *string  `json:"ipEqualFold,omitempty"`
	IPContainsFold *string  `json:"ipContainsFold,omitempty"`
	// reserved field predicates
	Reserved    *bool `json:"reserved,omitempty"`
	ReservedNeq *bool `json:"reservedNEQ,omitempty"`
	// ip_block edge predicates
	HasIPBlock     *bool                `json:"hasIPBlock,omitempty"`
	HasIPBlockWith []*IPBlockWhereInput `json:"hasIPBlockWith,omitempty"`
}

type IPBlock struct {
	// The ID of the IP Block.
	ID        gidx.PrefixedID `json:"id"`
	CreatedAt time.Time       `json:"createdAt"`
	UpdatedAt time.Time       `json:"updatedAt"`
	// The prefix of the ip block.
	Prefix string `json:"prefix"`
	// Allow carving this block into smaller subnets.
	AllowAutoSubnet bool `json:"allowAutoSubnet"`
	// Allow automatically assigning IPs directly from this block.
	AllowAutoAllocate bool                `json:"allowAutoAllocate"`
	IPBlockType       IPBlockType         `json:"ipBlockType"`
	IPAddress         IPAddressConnection `json:"ipAddress"`
}

func (IPBlock) IsNode() {}

// The id of the object.
func (this IPBlock) GetID() gidx.PrefixedID { return this.ID }

func (IPBlock) IsEntity() {}

// A connection to a list of items.
type IPBlockConnection struct {
	// A list of edges.
	Edges []*IPBlockEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createIPBlock mutation
type IPBlockCreatePayload struct {
	// Created ip block type
	IPBlock IPBlock `json:"ip_block"`
}

// Return response for deleteIPBlock mutation
type IPBlockDeletePayload struct {
	// Deleted ip block type
	DeletedID gidx.PrefixedID `json:"deletedID"`
}

// An edge in a connection.
type IPBlockEdge struct {
	// The item at the end of the edge.
	Node *IPBlock `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for IPBlock connections
type IPBlockOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order IPBlocks.
	Field IPBlockOrderField `json:"field"`
}

type IPBlockType struct {
	// The ID of the IP Block Type.
	ID        gidx.PrefixedID `json:"id"`
	CreatedAt time.Time       `json:"createdAt"`
	UpdatedAt time.Time       `json:"updatedAt"`
	// The name of the ip block type.
	Name    string            `json:"name"`
	IPBlock IPBlockConnection `json:"ipBlock"`
	// The owner of the ip block type.
	Owner Owner `json:"owner"`
}

func (IPBlockType) IsNode() {}

// The id of the object.
func (this IPBlockType) GetID() gidx.PrefixedID { return this.ID }

func (IPBlockType) IsEntity() {}

// A connection to a list of items.
type IPBlockTypeConnection struct {
	// A list of edges.
	Edges []*IPBlockTypeEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createIPBlockType mutation
type IPBlockTypeCreatePayload struct {
	// Created ip block type
	IPBlockType IPBlockType `json:"ip_block_type"`
}

// Return response for deleteIPBlockType mutation
type IPBlockTypeDeletePayload struct {
	// Deleted ip block type
	DeletedID gidx.PrefixedID `json:"deletedID"`
}

// An edge in a connection.
type IPBlockTypeEdge struct {
	// The item at the end of the edge.
	Node *IPBlockType `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for IPBlockType connections
type IPBlockTypeOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order IPBlockTypes.
	Field IPBlockTypeOrderField `json:"field"`
}

// Return response for updateIPBlockType mutation
type IPBlockTypeUpdatePayload struct {
	// Updated ip block type
	IPBlockType IPBlockType `json:"ip_block_type"`
}

// IPBlockTypeWhereInput is used for filtering IPBlockType objects.
// Input was generated by ent.
type IPBlockTypeWhereInput struct {
	Not *IPBlockTypeWhereInput   `json:"not,omitempty"`
	And []*IPBlockTypeWhereInput `json:"and,omitempty"`
	Or  []*IPBlockTypeWhereInput `json:"or,omitempty"`
	// id field predicates
	ID      *gidx.PrefixedID  `json:"id,omitempty"`
	IDNeq   *gidx.PrefixedID  `json:"idNEQ,omitempty"`
	IDIn    []gidx.PrefixedID `json:"idIn,omitempty"`
	IDNotIn []gidx.PrefixedID `json:"idNotIn,omitempty"`
	IDGt    *gidx.PrefixedID  `json:"idGT,omitempty"`
	IDGte   *gidx.PrefixedID  `json:"idGTE,omitempty"`
	IDLt    *gidx.PrefixedID  `json:"idLT,omitempty"`
	IDLte   *gidx.PrefixedID  `json:"idLTE,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// ip_block edge predicates
	HasIPBlock     *bool                `json:"hasIPBlock,omitempty"`
	HasIPBlockWith []*IPBlockWhereInput `json:"hasIPBlockWith,omitempty"`
}

// Return response for updateIPBlock mutation
type IPBlockUpdatePayload struct {
	// Updated ip block type
	IPBlock IPBlock `json:"ip_block"`
}

// IPBlockWhereInput is used for filtering IPBlock objects.
// Input was generated by ent.
type IPBlockWhereInput struct {
	Not *IPBlockWhereInput   `json:"not,omitempty"`
	And []*IPBlockWhereInput `json:"and,omitempty"`
	Or  []*IPBlockWhereInput `json:"or,omitempty"`
	// id field predicates
	ID      *gidx.PrefixedID  `json:"id,omitempty"`
	IDNeq   *gidx.PrefixedID  `json:"idNEQ,omitempty"`
	IDIn    []gidx.PrefixedID `json:"idIn,omitempty"`
	IDNotIn []gidx.PrefixedID `json:"idNotIn,omitempty"`
	IDGt    *gidx.PrefixedID  `json:"idGT,omitempty"`
	IDGte   *gidx.PrefixedID  `json:"idGTE,omitempty"`
	IDLt    *gidx.PrefixedID  `json:"idLT,omitempty"`
	IDLte   *gidx.PrefixedID  `json:"idLTE,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE,omitempty"`
	// prefix field predicates
	Prefix             *string  `json:"prefix,omitempty"`
	PrefixNeq          *string  `json:"prefixNEQ,omitempty"`
	PrefixIn           []string `json:"prefixIn,omitempty"`
	PrefixNotIn        []string `json:"prefixNotIn,omitempty"`
	PrefixGt           *string  `json:"prefixGT,omitempty"`
	PrefixGte          *string  `json:"prefixGTE,omitempty"`
	PrefixLt           *string  `json:"prefixLT,omitempty"`
	PrefixLte          *string  `json:"prefixLTE,omitempty"`
	PrefixContains     *string  `json:"prefixContains,omitempty"`
	PrefixHasPrefix    *string  `json:"prefixHasPrefix,omitempty"`
	PrefixHasSuffix    *string  `json:"prefixHasSuffix,omitempty"`
	PrefixEqualFold    *string  `json:"prefixEqualFold,omitempty"`
	PrefixContainsFold *string  `json:"prefixContainsFold,omitempty"`
	// allow_auto_subnet field predicates
	AllowAutoSubnet    *bool `json:"allowAutoSubnet,omitempty"`
	AllowAutoSubnetNeq *bool `json:"allowAutoSubnetNEQ,omitempty"`
	// allow_auto_allocate field predicates
	AllowAutoAllocate    *bool `json:"allowAutoAllocate,omitempty"`
	AllowAutoAllocateNeq *bool `json:"allowAutoAllocateNEQ,omitempty"`
	// ip_block_type edge predicates
	HasIPBlockType     *bool                    `json:"hasIPBlockType,omitempty"`
	HasIPBlockTypeWith []*IPBlockTypeWhereInput `json:"hasIPBlockTypeWith,omitempty"`
	// ip_address edge predicates
	HasIPAddress     *bool                  `json:"hasIPAddress,omitempty"`
	HasIPAddressWith []*IPAddressWhereInput `json:"hasIPAddressWith,omitempty"`
}

type Owner struct {
	ID          gidx.PrefixedID       `json:"id"`
	IPBlockType IPBlockTypeConnection `json:"ip_block_type"`
}

func (Owner) IsEntity() {}

// Information about pagination in a connection.
// https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
type PageInfo struct {
	// When paginating forwards, are there more items?
	HasNextPage bool `json:"hasNextPage"`
	// When paginating backwards, are there more items?
	HasPreviousPage bool `json:"hasPreviousPage"`
	// When paginating backwards, the cursor to continue.
	StartCursor *string `json:"startCursor,omitempty"`
	// When paginating forwards, the cursor to continue.
	EndCursor *string `json:"endCursor,omitempty"`
}

// Update an existing ip address type node.
type UpdateIPAddressInput struct {
	// The ip address.
	IP *string `json:"ip,omitempty"`
	// Reserve the IP without it being assigned.
	Reserved *bool `json:"reserved,omitempty"`
}

// Update an existing ip block type node.
type UpdateIPBlockInput struct {
	// The prefix of the ip block.
	Prefix *string `json:"prefix,omitempty"`
	// Allow carving this block into smaller subnets.
	AllowAutoSubnet *bool `json:"allowAutoSubnet,omitempty"`
	// Allow automatically assigning IPs directly from this block.
	AllowAutoAllocate *bool `json:"allowAutoAllocate,omitempty"`
}

// Update an existing ip block type node.
type UpdateIPBlockTypeInput struct {
	// The name of the ip block type.
	Name *string `json:"name,omitempty"`
}

type Service struct {
	Sdl *string `json:"sdl,omitempty"`
}

// Properties by which IPAddress connections can be ordered.
type IPAddressOrderField string

const (
	IPAddressOrderFieldID        IPAddressOrderField = "ID"
	IPAddressOrderFieldCreatedAt IPAddressOrderField = "CREATED_AT"
	IPAddressOrderFieldUpdatedAt IPAddressOrderField = "UPDATED_AT"
	IPAddressOrderFieldIP        IPAddressOrderField = "IP"
	IPAddressOrderFieldBlock     IPAddressOrderField = "BLOCK"
	IPAddressOrderFieldNode      IPAddressOrderField = "NODE"
	IPAddressOrderFieldOwner     IPAddressOrderField = "OWNER"
	IPAddressOrderFieldReserved  IPAddressOrderField = "RESERVED"
)

var AllIPAddressOrderField = []IPAddressOrderField{
	IPAddressOrderFieldID,
	IPAddressOrderFieldCreatedAt,
	IPAddressOrderFieldUpdatedAt,
	IPAddressOrderFieldIP,
	IPAddressOrderFieldBlock,
	IPAddressOrderFieldNode,
	IPAddressOrderFieldOwner,
	IPAddressOrderFieldReserved,
}

func (e IPAddressOrderField) IsValid() bool {
	switch e {
	case IPAddressOrderFieldID, IPAddressOrderFieldCreatedAt, IPAddressOrderFieldUpdatedAt, IPAddressOrderFieldIP, IPAddressOrderFieldBlock, IPAddressOrderFieldNode, IPAddressOrderFieldOwner, IPAddressOrderFieldReserved:
		return true
	}
	return false
}

func (e IPAddressOrderField) String() string {
	return string(e)
}

func (e *IPAddressOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IPAddressOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IPAddressOrderField", str)
	}
	return nil
}

func (e IPAddressOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which IPBlock connections can be ordered.
type IPBlockOrderField string

const (
	IPBlockOrderFieldID           IPBlockOrderField = "ID"
	IPBlockOrderFieldCreatedAt    IPBlockOrderField = "CREATED_AT"
	IPBlockOrderFieldUpdatedAt    IPBlockOrderField = "UPDATED_AT"
	IPBlockOrderFieldPrefix       IPBlockOrderField = "PREFIX"
	IPBlockOrderFieldBlockType    IPBlockOrderField = "BLOCK_TYPE"
	IPBlockOrderFieldLocation     IPBlockOrderField = "LOCATION"
	IPBlockOrderFieldParentBlock  IPBlockOrderField = "PARENT_BLOCK"
	IPBlockOrderFieldAutosubnet   IPBlockOrderField = "AUTOSUBNET"
	IPBlockOrderFieldAutoallocate IPBlockOrderField = "AUTOALLOCATE"
)

var AllIPBlockOrderField = []IPBlockOrderField{
	IPBlockOrderFieldID,
	IPBlockOrderFieldCreatedAt,
	IPBlockOrderFieldUpdatedAt,
	IPBlockOrderFieldPrefix,
	IPBlockOrderFieldBlockType,
	IPBlockOrderFieldLocation,
	IPBlockOrderFieldParentBlock,
	IPBlockOrderFieldAutosubnet,
	IPBlockOrderFieldAutoallocate,
}

func (e IPBlockOrderField) IsValid() bool {
	switch e {
	case IPBlockOrderFieldID, IPBlockOrderFieldCreatedAt, IPBlockOrderFieldUpdatedAt, IPBlockOrderFieldPrefix, IPBlockOrderFieldBlockType, IPBlockOrderFieldLocation, IPBlockOrderFieldParentBlock, IPBlockOrderFieldAutosubnet, IPBlockOrderFieldAutoallocate:
		return true
	}
	return false
}

func (e IPBlockOrderField) String() string {
	return string(e)
}

func (e *IPBlockOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IPBlockOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IPBlockOrderField", str)
	}
	return nil
}

func (e IPBlockOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which IPBlockType connections can be ordered.
type IPBlockTypeOrderField string

const (
	IPBlockTypeOrderFieldID        IPBlockTypeOrderField = "ID"
	IPBlockTypeOrderFieldCreatedAt IPBlockTypeOrderField = "CREATED_AT"
	IPBlockTypeOrderFieldUpdatedAt IPBlockTypeOrderField = "UPDATED_AT"
	IPBlockTypeOrderFieldName      IPBlockTypeOrderField = "NAME"
	IPBlockTypeOrderFieldOwner     IPBlockTypeOrderField = "OWNER"
)

var AllIPBlockTypeOrderField = []IPBlockTypeOrderField{
	IPBlockTypeOrderFieldID,
	IPBlockTypeOrderFieldCreatedAt,
	IPBlockTypeOrderFieldUpdatedAt,
	IPBlockTypeOrderFieldName,
	IPBlockTypeOrderFieldOwner,
}

func (e IPBlockTypeOrderField) IsValid() bool {
	switch e {
	case IPBlockTypeOrderFieldID, IPBlockTypeOrderFieldCreatedAt, IPBlockTypeOrderFieldUpdatedAt, IPBlockTypeOrderFieldName, IPBlockTypeOrderFieldOwner:
		return true
	}
	return false
}

func (e IPBlockTypeOrderField) String() string {
	return string(e)
}

func (e *IPBlockTypeOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IPBlockTypeOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IPBlockTypeOrderField", str)
	}
	return nil
}

func (e IPBlockTypeOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible directions in which to order a list of items when provided an `orderBy` argument.
type OrderDirection string

const (
	// Specifies an ascending order for a given `orderBy` argument.
	OrderDirectionAsc OrderDirection = "ASC"
	// Specifies a descending order for a given `orderBy` argument.
	OrderDirectionDesc OrderDirection = "DESC"
)

var AllOrderDirection = []OrderDirection{
	OrderDirectionAsc,
	OrderDirectionDesc,
}

func (e OrderDirection) IsValid() bool {
	switch e {
	case OrderDirectionAsc, OrderDirectionDesc:
		return true
	}
	return false
}

func (e OrderDirection) String() string {
	return string(e)
}

func (e *OrderDirection) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderDirection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderDirection", str)
	}
	return nil
}

func (e OrderDirection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
