// Code generated by github.com/Yamashou/gqlgenc, DO NOT EDIT.

package testclient

import (
	"context"
	"net/http"
	"time"

	"github.com/Yamashou/gqlgenc/client"
	"go.infratographer.com/x/gidx"
)

type TestClient interface {
	CreateIPAddress(ctx context.Context, input CreateIPAddressInput, httpRequestOptions ...client.HTTPRequestOption) (*CreateIPAddress, error)
	DeleteIPAddress(ctx context.Context, id gidx.PrefixedID, httpRequestOptions ...client.HTTPRequestOption) (*DeleteIPAddress, error)
	GetIPAddressesByNode(ctx context.Context, id gidx.PrefixedID, httpRequestOptions ...client.HTTPRequestOption) (*GetIPAddressesByNode, error)
	GetIPBlock(ctx context.Context, id gidx.PrefixedID, httpRequestOptions ...client.HTTPRequestOption) (*GetIPBlock, error)
	GetIPBlockType(ctx context.Context, id gidx.PrefixedID, httpRequestOptions ...client.HTTPRequestOption) (*GetIPBlockType, error)
	IPBlockCreate(ctx context.Context, input CreateIPBlockInput, httpRequestOptions ...client.HTTPRequestOption) (*IPBlockCreate, error)
	IPBlockDelete(ctx context.Context, id gidx.PrefixedID, httpRequestOptions ...client.HTTPRequestOption) (*IPBlockDelete, error)
	IPBlockTypeCreate(ctx context.Context, input CreateIPBlockTypeInput, httpRequestOptions ...client.HTTPRequestOption) (*IPBlockTypeCreate, error)
	IPBlockTypeDelete(ctx context.Context, id gidx.PrefixedID, httpRequestOptions ...client.HTTPRequestOption) (*IPBlockTypeDelete, error)
	IPBlockTypeUpdate(ctx context.Context, id gidx.PrefixedID, input UpdateIPBlockTypeInput, httpRequestOptions ...client.HTTPRequestOption) (*IPBlockTypeUpdate, error)
	IPBlockUpdate(ctx context.Context, id gidx.PrefixedID, input UpdateIPBlockInput, httpRequestOptions ...client.HTTPRequestOption) (*IPBlockUpdate, error)
	ListIPBlockTypes(ctx context.Context, id gidx.PrefixedID, orderBy *IPBlockTypeOrder, httpRequestOptions ...client.HTTPRequestOption) (*ListIPBlockTypes, error)
	UpdateIPAddress(ctx context.Context, id gidx.PrefixedID, input UpdateIPAddressInput, httpRequestOptions ...client.HTTPRequestOption) (*UpdateIPAddress, error)
	GetIPAddress(ctx context.Context, id gidx.PrefixedID, httpRequestOptions ...client.HTTPRequestOption) (*GetIPAddress, error)
}

type Client struct {
	Client *client.Client
}

func NewClient(cli *http.Client, baseURL string, options ...client.HTTPRequestOption) TestClient {
	return &Client{Client: client.NewClient(cli, baseURL, options...)}
}

type Query struct {
	IPAddress   IPAddress   "json:\"ipAddress\" graphql:\"ipAddress\""
	IPBlock     IPBlock     "json:\"ipBlock\" graphql:\"ipBlock\""
	IPBlockType IPBlockType "json:\"ipBlockType\" graphql:\"ipBlockType\""
	Entities    []Entity    "json:\"_entities\" graphql:\"_entities\""
	Service     Service     "json:\"_service\" graphql:\"_service\""
}
type Mutation struct {
	CreateIPAddress   IPAddressCreatePayload   "json:\"createIPAddress\" graphql:\"createIPAddress\""
	UpdateIPAddress   IPAddressUpdatePayload   "json:\"updateIPAddress\" graphql:\"updateIPAddress\""
	DeleteIPAddress   IPAddressDeletePayload   "json:\"deleteIPAddress\" graphql:\"deleteIPAddress\""
	CreateIPBlock     IPBlockCreatePayload     "json:\"createIPBlock\" graphql:\"createIPBlock\""
	UpdateIPBlock     IPBlockUpdatePayload     "json:\"updateIPBlock\" graphql:\"updateIPBlock\""
	DeleteIPBlock     IPBlockDeletePayload     "json:\"deleteIPBlock\" graphql:\"deleteIPBlock\""
	CreateIPBlockType IPBlockTypeCreatePayload "json:\"createIPBlockType\" graphql:\"createIPBlockType\""
	UpdateIPBlockType IPBlockTypeUpdatePayload "json:\"updateIPBlockType\" graphql:\"updateIPBlockType\""
	DeleteIPBlockType IPBlockTypeDeletePayload "json:\"deleteIPBlockType\" graphql:\"deleteIPBlockType\""
}
type CreateIPAddress struct {
	CreateIPAddress struct {
		IPAddress struct {
			ID       gidx.PrefixedID "json:\"id\" graphql:\"id\""
			IP       string          "json:\"ip\" graphql:\"ip\""
			Reserved bool            "json:\"reserved\" graphql:\"reserved\""
			IPBlock  struct {
				ID        gidx.PrefixedID "json:\"id\" graphql:\"id\""
				IPAddress struct {
					Edges []*struct {
						Node *struct {
							ID gidx.PrefixedID "json:\"id\" graphql:\"id\""
							IP string          "json:\"ip\" graphql:\"ip\""
						} "json:\"node\" graphql:\"node\""
					} "json:\"edges\" graphql:\"edges\""
				} "json:\"ipAddress\" graphql:\"ipAddress\""
			} "json:\"ipBlock\" graphql:\"ipBlock\""
		} "json:\"ipAddress\" graphql:\"ipAddress\""
	} "json:\"createIPAddress\" graphql:\"createIPAddress\""
}
type DeleteIPAddress struct {
	DeleteIPAddress struct {
		DeletedID gidx.PrefixedID "json:\"deletedID\" graphql:\"deletedID\""
	} "json:\"deleteIPAddress\" graphql:\"deleteIPAddress\""
}
type GetIPAddressesByNode struct {
	Entities []*struct {
		IPAddresses []*struct {
			IP string "json:\"ip\" graphql:\"ip\""
		} "json:\"ipAddresses\" graphql:\"ipAddresses\""
	} "json:\"_entities\" graphql:\"_entities\""
}
type GetIPBlock struct {
	IPBlock struct {
		ID                gidx.PrefixedID "json:\"id\" graphql:\"id\""
		Prefix            string          "json:\"prefix\" graphql:\"prefix\""
		AllowAutoSubnet   bool            "json:\"allowAutoSubnet\" graphql:\"allowAutoSubnet\""
		AllowAutoAllocate bool            "json:\"allowAutoAllocate\" graphql:\"allowAutoAllocate\""
		IPBlockType       struct {
			ID gidx.PrefixedID "json:\"id\" graphql:\"id\""
		} "json:\"ipBlockType\" graphql:\"ipBlockType\""
		IPAddress struct {
			Edges []*struct {
				Node *struct {
					ID       gidx.PrefixedID "json:\"id\" graphql:\"id\""
					IP       string          "json:\"ip\" graphql:\"ip\""
					Reserved bool            "json:\"reserved\" graphql:\"reserved\""
				} "json:\"node\" graphql:\"node\""
			} "json:\"edges\" graphql:\"edges\""
		} "json:\"ipAddress\" graphql:\"ipAddress\""
	} "json:\"ipBlock\" graphql:\"ipBlock\""
}
type GetIPBlockType struct {
	IPBlockType struct {
		ID    gidx.PrefixedID "json:\"id\" graphql:\"id\""
		Name  string          "json:\"name\" graphql:\"name\""
		Owner struct {
			ID gidx.PrefixedID "json:\"id\" graphql:\"id\""
		} "json:\"owner\" graphql:\"owner\""
		CreatedAt time.Time "json:\"createdAt\" graphql:\"createdAt\""
		UpdatedAt time.Time "json:\"updatedAt\" graphql:\"updatedAt\""
	} "json:\"ipBlockType\" graphql:\"ipBlockType\""
}
type IPBlockCreate struct {
	CreateIPBlock struct {
		IPBlock struct {
			ID                gidx.PrefixedID "json:\"id\" graphql:\"id\""
			Prefix            string          "json:\"prefix\" graphql:\"prefix\""
			AllowAutoSubnet   bool            "json:\"allowAutoSubnet\" graphql:\"allowAutoSubnet\""
			AllowAutoAllocate bool            "json:\"allowAutoAllocate\" graphql:\"allowAutoAllocate\""
			IPBlockType       struct {
				ID gidx.PrefixedID "json:\"id\" graphql:\"id\""
			} "json:\"ipBlockType\" graphql:\"ipBlockType\""
			IPAddress struct {
				Edges []*struct {
					Node *struct {
						ID       gidx.PrefixedID "json:\"id\" graphql:\"id\""
						IP       string          "json:\"ip\" graphql:\"ip\""
						Reserved bool            "json:\"reserved\" graphql:\"reserved\""
					} "json:\"node\" graphql:\"node\""
				} "json:\"edges\" graphql:\"edges\""
			} "json:\"ipAddress\" graphql:\"ipAddress\""
		} "json:\"ipBlock\" graphql:\"ipBlock\""
	} "json:\"createIPBlock\" graphql:\"createIPBlock\""
}
type IPBlockDelete struct {
	DeleteIPBlock struct {
		DeletedID gidx.PrefixedID "json:\"deletedID\" graphql:\"deletedID\""
	} "json:\"deleteIPBlock\" graphql:\"deleteIPBlock\""
}
type IPBlockTypeCreate struct {
	CreateIPBlockType struct {
		IPBlockType struct {
			ID    gidx.PrefixedID "json:\"id\" graphql:\"id\""
			Name  string          "json:\"name\" graphql:\"name\""
			Owner struct {
				ID gidx.PrefixedID "json:\"id\" graphql:\"id\""
			} "json:\"owner\" graphql:\"owner\""
			CreatedAt time.Time "json:\"createdAt\" graphql:\"createdAt\""
			UpdatedAt time.Time "json:\"updatedAt\" graphql:\"updatedAt\""
		} "json:\"ipBlockType\" graphql:\"ipBlockType\""
	} "json:\"createIPBlockType\" graphql:\"createIPBlockType\""
}
type IPBlockTypeDelete struct {
	DeleteIPBlockType struct {
		DeletedID gidx.PrefixedID "json:\"deletedID\" graphql:\"deletedID\""
	} "json:\"deleteIPBlockType\" graphql:\"deleteIPBlockType\""
}
type IPBlockTypeUpdate struct {
	UpdateIPBlockType struct {
		IPBlockType struct {
			ID        gidx.PrefixedID "json:\"id\" graphql:\"id\""
			Name      string          "json:\"name\" graphql:\"name\""
			CreatedAt time.Time       "json:\"createdAt\" graphql:\"createdAt\""
			UpdatedAt time.Time       "json:\"updatedAt\" graphql:\"updatedAt\""
		} "json:\"ipBlockType\" graphql:\"ipBlockType\""
	} "json:\"updateIPBlockType\" graphql:\"updateIPBlockType\""
}
type IPBlockUpdate struct {
	UpdateIPBlock struct {
		IPBlock struct {
			ID                gidx.PrefixedID "json:\"id\" graphql:\"id\""
			Prefix            string          "json:\"prefix\" graphql:\"prefix\""
			AllowAutoSubnet   bool            "json:\"allowAutoSubnet\" graphql:\"allowAutoSubnet\""
			AllowAutoAllocate bool            "json:\"allowAutoAllocate\" graphql:\"allowAutoAllocate\""
			IPBlockType       struct {
				ID gidx.PrefixedID "json:\"id\" graphql:\"id\""
			} "json:\"ipBlockType\" graphql:\"ipBlockType\""
			IPAddress struct {
				Edges []*struct {
					Node *struct {
						ID       gidx.PrefixedID "json:\"id\" graphql:\"id\""
						IP       string          "json:\"ip\" graphql:\"ip\""
						Reserved bool            "json:\"reserved\" graphql:\"reserved\""
					} "json:\"node\" graphql:\"node\""
				} "json:\"edges\" graphql:\"edges\""
			} "json:\"ipAddress\" graphql:\"ipAddress\""
		} "json:\"ipBlock\" graphql:\"ipBlock\""
	} "json:\"updateIPBlock\" graphql:\"updateIPBlock\""
}
type ListIPBlockTypes struct {
	Entities []*struct {
		IPBlockType struct {
			Edges []*struct {
				Node *struct {
					ID   gidx.PrefixedID "json:\"id\" graphql:\"id\""
					Name string          "json:\"name\" graphql:\"name\""
				} "json:\"node\" graphql:\"node\""
			} "json:\"edges\" graphql:\"edges\""
		} "json:\"ipBlockType\" graphql:\"ipBlockType\""
	} "json:\"_entities\" graphql:\"_entities\""
}
type UpdateIPAddress struct {
	UpdateIPAddress struct {
		IPAddress struct {
			ID       gidx.PrefixedID "json:\"id\" graphql:\"id\""
			IP       string          "json:\"ip\" graphql:\"ip\""
			Reserved bool            "json:\"reserved\" graphql:\"reserved\""
			IPBlock  struct {
				ID        gidx.PrefixedID "json:\"id\" graphql:\"id\""
				IPAddress struct {
					Edges []*struct {
						Node *struct {
							ID gidx.PrefixedID "json:\"id\" graphql:\"id\""
							IP string          "json:\"ip\" graphql:\"ip\""
						} "json:\"node\" graphql:\"node\""
					} "json:\"edges\" graphql:\"edges\""
				} "json:\"ipAddress\" graphql:\"ipAddress\""
			} "json:\"ipBlock\" graphql:\"ipBlock\""
		} "json:\"ipAddress\" graphql:\"ipAddress\""
	} "json:\"updateIPAddress\" graphql:\"updateIPAddress\""
}
type GetIPAddress struct {
	IPAddress struct {
		ID       gidx.PrefixedID "json:\"id\" graphql:\"id\""
		IP       string          "json:\"ip\" graphql:\"ip\""
		Reserved bool            "json:\"reserved\" graphql:\"reserved\""
		IPBlock  struct {
			ID                gidx.PrefixedID "json:\"id\" graphql:\"id\""
			Prefix            string          "json:\"prefix\" graphql:\"prefix\""
			AllowAutoAllocate bool            "json:\"allowAutoAllocate\" graphql:\"allowAutoAllocate\""
			AllowAutoSubnet   bool            "json:\"allowAutoSubnet\" graphql:\"allowAutoSubnet\""
		} "json:\"ipBlock\" graphql:\"ipBlock\""
	} "json:\"ipAddress\" graphql:\"ipAddress\""
}

const CreateIPAddressDocument = `mutation CreateIPAddress ($input: CreateIPAddressInput!) {
	createIPAddress(input: $input) {
		ipAddress {
			id
			ip
			reserved
			ipBlock {
				id
				ipAddress {
					edges {
						node {
							id
							ip
						}
					}
				}
			}
		}
	}
}
`

func (c *Client) CreateIPAddress(ctx context.Context, input CreateIPAddressInput, httpRequestOptions ...client.HTTPRequestOption) (*CreateIPAddress, error) {
	vars := map[string]interface{}{
		"input": input,
	}

	var res CreateIPAddress
	if err := c.Client.Post(ctx, "CreateIPAddress", CreateIPAddressDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const DeleteIPAddressDocument = `mutation DeleteIPAddress ($id: ID!) {
	deleteIPAddress(id: $id) {
		deletedID
	}
}
`

func (c *Client) DeleteIPAddress(ctx context.Context, id gidx.PrefixedID, httpRequestOptions ...client.HTTPRequestOption) (*DeleteIPAddress, error) {
	vars := map[string]interface{}{
		"id": id,
	}

	var res DeleteIPAddress
	if err := c.Client.Post(ctx, "DeleteIPAddress", DeleteIPAddressDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const GetIPAddressesByNodeDocument = `query GetIPAddressesByNode ($id: ID!) {
	_entities(representations: {__typename:"IPAddressable",id:$id}) {
		... on IPAddressable {
			ipAddresses {
				ip
			}
		}
	}
}
`

func (c *Client) GetIPAddressesByNode(ctx context.Context, id gidx.PrefixedID, httpRequestOptions ...client.HTTPRequestOption) (*GetIPAddressesByNode, error) {
	vars := map[string]interface{}{
		"id": id,
	}

	var res GetIPAddressesByNode
	if err := c.Client.Post(ctx, "GetIPAddressesByNode", GetIPAddressesByNodeDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const GetIPBlockDocument = `query GetIPBlock ($id: ID!) {
	ipBlock(id: $id) {
		id
		prefix
		allowAutoSubnet
		allowAutoAllocate
		ipBlockType {
			id
		}
		ipAddress {
			edges {
				node {
					id
					ip
					reserved
				}
			}
		}
	}
}
`

func (c *Client) GetIPBlock(ctx context.Context, id gidx.PrefixedID, httpRequestOptions ...client.HTTPRequestOption) (*GetIPBlock, error) {
	vars := map[string]interface{}{
		"id": id,
	}

	var res GetIPBlock
	if err := c.Client.Post(ctx, "GetIPBlock", GetIPBlockDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const GetIPBlockTypeDocument = `query GetIPBlockType ($id: ID!) {
	ipBlockType(id: $id) {
		id
		name
		owner {
			id
		}
		createdAt
		updatedAt
	}
}
`

func (c *Client) GetIPBlockType(ctx context.Context, id gidx.PrefixedID, httpRequestOptions ...client.HTTPRequestOption) (*GetIPBlockType, error) {
	vars := map[string]interface{}{
		"id": id,
	}

	var res GetIPBlockType
	if err := c.Client.Post(ctx, "GetIPBlockType", GetIPBlockTypeDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const IPBlockCreateDocument = `mutation IPBlockCreate ($input: CreateIPBlockInput!) {
	createIPBlock(input: $input) {
		ipBlock {
			id
			prefix
			allowAutoSubnet
			allowAutoAllocate
			ipBlockType {
				id
			}
			ipAddress {
				edges {
					node {
						id
						ip
						reserved
					}
				}
			}
		}
	}
}
`

func (c *Client) IPBlockCreate(ctx context.Context, input CreateIPBlockInput, httpRequestOptions ...client.HTTPRequestOption) (*IPBlockCreate, error) {
	vars := map[string]interface{}{
		"input": input,
	}

	var res IPBlockCreate
	if err := c.Client.Post(ctx, "IPBlockCreate", IPBlockCreateDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const IPBlockDeleteDocument = `mutation IPBlockDelete ($id: ID!) {
	deleteIPBlock(id: $id) {
		deletedID
	}
}
`

func (c *Client) IPBlockDelete(ctx context.Context, id gidx.PrefixedID, httpRequestOptions ...client.HTTPRequestOption) (*IPBlockDelete, error) {
	vars := map[string]interface{}{
		"id": id,
	}

	var res IPBlockDelete
	if err := c.Client.Post(ctx, "IPBlockDelete", IPBlockDeleteDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const IPBlockTypeCreateDocument = `mutation IPBlockTypeCreate ($input: CreateIPBlockTypeInput!) {
	createIPBlockType(input: $input) {
		ipBlockType {
			id
			name
			owner {
				id
			}
			createdAt
			updatedAt
		}
	}
}
`

func (c *Client) IPBlockTypeCreate(ctx context.Context, input CreateIPBlockTypeInput, httpRequestOptions ...client.HTTPRequestOption) (*IPBlockTypeCreate, error) {
	vars := map[string]interface{}{
		"input": input,
	}

	var res IPBlockTypeCreate
	if err := c.Client.Post(ctx, "IPBlockTypeCreate", IPBlockTypeCreateDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const IPBlockTypeDeleteDocument = `mutation IPBlockTypeDelete ($id: ID!) {
	deleteIPBlockType(id: $id) {
		deletedID
	}
}
`

func (c *Client) IPBlockTypeDelete(ctx context.Context, id gidx.PrefixedID, httpRequestOptions ...client.HTTPRequestOption) (*IPBlockTypeDelete, error) {
	vars := map[string]interface{}{
		"id": id,
	}

	var res IPBlockTypeDelete
	if err := c.Client.Post(ctx, "IPBlockTypeDelete", IPBlockTypeDeleteDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const IPBlockTypeUpdateDocument = `mutation IPBlockTypeUpdate ($id: ID!, $input: UpdateIPBlockTypeInput!) {
	updateIPBlockType(id: $id, input: $input) {
		ipBlockType {
			id
			name
			createdAt
			updatedAt
		}
	}
}
`

func (c *Client) IPBlockTypeUpdate(ctx context.Context, id gidx.PrefixedID, input UpdateIPBlockTypeInput, httpRequestOptions ...client.HTTPRequestOption) (*IPBlockTypeUpdate, error) {
	vars := map[string]interface{}{
		"id":    id,
		"input": input,
	}

	var res IPBlockTypeUpdate
	if err := c.Client.Post(ctx, "IPBlockTypeUpdate", IPBlockTypeUpdateDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const IPBlockUpdateDocument = `mutation IPBlockUpdate ($id: ID!, $input: UpdateIPBlockInput!) {
	updateIPBlock(id: $id, input: $input) {
		ipBlock {
			id
			prefix
			allowAutoSubnet
			allowAutoAllocate
			ipBlockType {
				id
			}
			ipAddress {
				edges {
					node {
						id
						ip
						reserved
					}
				}
			}
		}
	}
}
`

func (c *Client) IPBlockUpdate(ctx context.Context, id gidx.PrefixedID, input UpdateIPBlockInput, httpRequestOptions ...client.HTTPRequestOption) (*IPBlockUpdate, error) {
	vars := map[string]interface{}{
		"id":    id,
		"input": input,
	}

	var res IPBlockUpdate
	if err := c.Client.Post(ctx, "IPBlockUpdate", IPBlockUpdateDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const ListIPBlockTypesDocument = `query ListIPBlockTypes ($id: ID!, $orderBy: IPBlockTypeOrder) {
	_entities(representations: [{__typename:"ResourceOwner",id:$id}]) {
		... on ResourceOwner {
			ipBlockType(orderBy: $orderBy) {
				edges {
					node {
						id
						name
					}
				}
			}
		}
	}
}
`

func (c *Client) ListIPBlockTypes(ctx context.Context, id gidx.PrefixedID, orderBy *IPBlockTypeOrder, httpRequestOptions ...client.HTTPRequestOption) (*ListIPBlockTypes, error) {
	vars := map[string]interface{}{
		"id":      id,
		"orderBy": orderBy,
	}

	var res ListIPBlockTypes
	if err := c.Client.Post(ctx, "ListIPBlockTypes", ListIPBlockTypesDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const UpdateIPAddressDocument = `mutation UpdateIPAddress ($id: ID!, $input: UpdateIPAddressInput!) {
	updateIPAddress(id: $id, input: $input) {
		ipAddress {
			id
			ip
			reserved
			ipBlock {
				id
				ipAddress {
					edges {
						node {
							id
							ip
						}
					}
				}
			}
		}
	}
}
`

func (c *Client) UpdateIPAddress(ctx context.Context, id gidx.PrefixedID, input UpdateIPAddressInput, httpRequestOptions ...client.HTTPRequestOption) (*UpdateIPAddress, error) {
	vars := map[string]interface{}{
		"id":    id,
		"input": input,
	}

	var res UpdateIPAddress
	if err := c.Client.Post(ctx, "UpdateIPAddress", UpdateIPAddressDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const GetIPAddressDocument = `query getIPAddress ($id: ID!) {
	ipAddress(id: $id) {
		id
		ip
		reserved
		ipBlock {
			id
			prefix
			allowAutoAllocate
			allowAutoSubnet
		}
	}
}
`

func (c *Client) GetIPAddress(ctx context.Context, id gidx.PrefixedID, httpRequestOptions ...client.HTTPRequestOption) (*GetIPAddress, error) {
	vars := map[string]interface{}{
		"id": id,
	}

	var res GetIPAddress
	if err := c.Client.Post(ctx, "getIPAddress", GetIPAddressDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}
