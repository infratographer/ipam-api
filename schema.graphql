directive @goField(forceResolver: Boolean, name: String) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION
directive @goModel(model: String, models: [String!]) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION
"""Create a new ip address type node."""
input CreateIPAddressInput {
	"""The ip address."""
	ip: String!
	"""The ID for the node this is assigned to."""
	nodeID: ID!
	"""Owner ID of the node this is assigned to."""
	nodeOwnerID: ID!
	"""Reserve the IP without it being assigned."""
	reserved: Boolean
	ipBlockID: ID!
}
"""Create a new ip block type node."""
input CreateIPBlockInput {
	"""The prefix of the ip block."""
	prefix: String!
	"""The ID for the location for this ip block."""
	locationID: ID!
	"""The ID for the parent of this ip block."""
	parentBlockID: ID!
	"""Allow carving this block into smaller subnets."""
	allowAutoSubnet: Boolean
	"""Allow automatically assigning IPs directly from this block."""
	allowAutoAllocate: Boolean
	ipBlockTypeID: ID!
}
"""Create a new ip block type node."""
input CreateIPBlockTypeInput {
	"""The name of the ip block type."""
	name: String!
	"""The ID for the owner for this ip block type."""
	ownerID: ID!
}
"""
Define a Relay Cursor type:
https://relay.dev/graphql/connections.htm#sec-Cursor
"""
scalar Cursor
type IPAddress implements Node @key(fields: "id") {
	"""The ID of the IP Address."""
	id: ID!
	createdAt: Time!
	updatedAt: Time!
	"""The ip address."""
	ip: String!
	"""Reserve the IP without it being assigned."""
	reserved: Boolean!
	ipBlock: IPBlock!
}
"""A connection to a list of items."""
type IPAddressConnection {
	"""A list of edges."""
	edges: [IPAddressEdge]
	"""Information to aid in pagination."""
	pageInfo: PageInfo!
	"""Identifies the total count of items in the connection."""
	totalCount: Int!
}
"""Return response for createIPAddress mutation"""
type IPAddressCreatePayload {
	"""Created ip block type"""
	ip_address: IPAddress!
}
"""Return response for deleteIPAddress mutation"""
type IPAddressDeletePayload {
	"""Deleted ip block type"""
	deletedID: ID!
}
"""An edge in a connection."""
type IPAddressEdge {
	"""The item at the end of the edge."""
	node: IPAddress
	"""A cursor for use in pagination."""
	cursor: Cursor!
}
"""Ordering options for IPAddress connections"""
input IPAddressOrder {
	"""The ordering direction."""
	direction: OrderDirection! = ASC
	"""The field by which to order IPAddresses."""
	field: IPAddressOrderField!
}
"""Properties by which IPAddress connections can be ordered."""
enum IPAddressOrderField {
	ID
	CREATED_AT
	UPDATED_AT
	IP
	BLOCK
	NODE
	OWNER
	RESERVED
}
"""Return response for updateIPAddress mutation"""
type IPAddressUpdatePayload {
	"""Updated ip block type"""
	ip_address: IPAddress!
}
"""
IPAddressWhereInput is used for filtering IPAddress objects.
Input was generated by ent.
"""
input IPAddressWhereInput {
	not: IPAddressWhereInput
	and: [IPAddressWhereInput!]
	or: [IPAddressWhereInput!]
	"""id field predicates"""
	id: ID
	idNEQ: ID
	idIn: [ID!]
	idNotIn: [ID!]
	idGT: ID
	idGTE: ID
	idLT: ID
	idLTE: ID
	"""created_at field predicates"""
	createdAt: Time
	createdAtNEQ: Time
	createdAtIn: [Time!]
	createdAtNotIn: [Time!]
	createdAtGT: Time
	createdAtGTE: Time
	createdAtLT: Time
	createdAtLTE: Time
	"""updated_at field predicates"""
	updatedAt: Time
	updatedAtNEQ: Time
	updatedAtIn: [Time!]
	updatedAtNotIn: [Time!]
	updatedAtGT: Time
	updatedAtGTE: Time
	updatedAtLT: Time
	updatedAtLTE: Time
	"""IP field predicates"""
	ip: String
	ipNEQ: String
	ipIn: [String!]
	ipNotIn: [String!]
	ipGT: String
	ipGTE: String
	ipLT: String
	ipLTE: String
	ipContains: String
	ipHasPrefix: String
	ipHasSuffix: String
	ipEqualFold: String
	ipContainsFold: String
	"""reserved field predicates"""
	reserved: Boolean
	reservedNEQ: Boolean
	"""ip_block edge predicates"""
	hasIPBlock: Boolean
	hasIPBlockWith: [IPBlockWhereInput!]
}
type IPBlock implements Node @key(fields: "id") {
	"""The ID of the IP Block."""
	id: ID!
	createdAt: Time!
	updatedAt: Time!
	"""The prefix of the ip block."""
	prefix: String!
	"""Allow carving this block into smaller subnets."""
	allowAutoSubnet: Boolean!
	"""Allow automatically assigning IPs directly from this block."""
	allowAutoAllocate: Boolean!
	ipBlockType: IPBlockType!
	ipAddress(
		"""Returns the elements in the list that come after the specified cursor."""
		after: Cursor

		"""Returns the first _n_ elements from the list."""
		first: Int

		"""Returns the elements in the list that come before the specified cursor."""
		before: Cursor

		"""Returns the last _n_ elements from the list."""
		last: Int

		"""Ordering options for IPAddresses returned from the connection."""
		orderBy: IPAddressOrder

		"""Filtering options for IPAddresses returned from the connection."""
		where: IPAddressWhereInput
	): IPAddressConnection!
}
"""A connection to a list of items."""
type IPBlockConnection {
	"""A list of edges."""
	edges: [IPBlockEdge]
	"""Information to aid in pagination."""
	pageInfo: PageInfo!
	"""Identifies the total count of items in the connection."""
	totalCount: Int!
}
"""Return response for createIPBlock mutation"""
type IPBlockCreatePayload {
	"""Created ip block type"""
	ip_block: IPBlock!
}
"""Return response for deleteIPBlock mutation"""
type IPBlockDeletePayload {
	"""Deleted ip block type"""
	deletedID: ID!
}
"""An edge in a connection."""
type IPBlockEdge {
	"""The item at the end of the edge."""
	node: IPBlock
	"""A cursor for use in pagination."""
	cursor: Cursor!
}
"""Ordering options for IPBlock connections"""
input IPBlockOrder {
	"""The ordering direction."""
	direction: OrderDirection! = ASC
	"""The field by which to order IPBlocks."""
	field: IPBlockOrderField!
}
"""Properties by which IPBlock connections can be ordered."""
enum IPBlockOrderField {
	ID
	CREATED_AT
	UPDATED_AT
	PREFIX
	BLOCK_TYPE
	LOCATION
	PARENT_BLOCK
	AUTOSUBNET
	AUTOALLOCATE
}
type IPBlockType implements Node @key(fields: "id") {
	"""The ID of the IP Block Type."""
	id: ID!
	createdAt: Time!
	updatedAt: Time!
	"""The name of the ip block type."""
	name: String!
	ipBlock(
		"""Returns the elements in the list that come after the specified cursor."""
		after: Cursor

		"""Returns the first _n_ elements from the list."""
		first: Int

		"""Returns the elements in the list that come before the specified cursor."""
		before: Cursor

		"""Returns the last _n_ elements from the list."""
		last: Int

		"""Ordering options for IPBlocks returned from the connection."""
		orderBy: IPBlockOrder

		"""Filtering options for IPBlocks returned from the connection."""
		where: IPBlockWhereInput
	): IPBlockConnection!
	"""The owner of the ip block type."""
	owner: Owner! @goField(forceResolver: true)
}
"""A connection to a list of items."""
type IPBlockTypeConnection {
	"""A list of edges."""
	edges: [IPBlockTypeEdge]
	"""Information to aid in pagination."""
	pageInfo: PageInfo!
	"""Identifies the total count of items in the connection."""
	totalCount: Int!
}
"""Return response for createIPBlockType mutation"""
type IPBlockTypeCreatePayload {
	"""Created ip block type"""
	ip_block_type: IPBlockType!
}
"""Return response for deleteIPBlockType mutation"""
type IPBlockTypeDeletePayload {
	"""Deleted ip block type"""
	deletedID: ID!
}
"""An edge in a connection."""
type IPBlockTypeEdge {
	"""The item at the end of the edge."""
	node: IPBlockType
	"""A cursor for use in pagination."""
	cursor: Cursor!
}
"""Ordering options for IPBlockType connections"""
input IPBlockTypeOrder {
	"""The ordering direction."""
	direction: OrderDirection! = ASC
	"""The field by which to order IPBlockTypes."""
	field: IPBlockTypeOrderField!
}
"""Properties by which IPBlockType connections can be ordered."""
enum IPBlockTypeOrderField {
	ID
	CREATED_AT
	UPDATED_AT
	NAME
	OWNER
}
"""Return response for updateIPBlockType mutation"""
type IPBlockTypeUpdatePayload {
	"""Updated ip block type"""
	ip_block_type: IPBlockType!
}
"""
IPBlockTypeWhereInput is used for filtering IPBlockType objects.
Input was generated by ent.
"""
input IPBlockTypeWhereInput {
	not: IPBlockTypeWhereInput
	and: [IPBlockTypeWhereInput!]
	or: [IPBlockTypeWhereInput!]
	"""id field predicates"""
	id: ID
	idNEQ: ID
	idIn: [ID!]
	idNotIn: [ID!]
	idGT: ID
	idGTE: ID
	idLT: ID
	idLTE: ID
	"""created_at field predicates"""
	createdAt: Time
	createdAtNEQ: Time
	createdAtIn: [Time!]
	createdAtNotIn: [Time!]
	createdAtGT: Time
	createdAtGTE: Time
	createdAtLT: Time
	createdAtLTE: Time
	"""updated_at field predicates"""
	updatedAt: Time
	updatedAtNEQ: Time
	updatedAtIn: [Time!]
	updatedAtNotIn: [Time!]
	updatedAtGT: Time
	updatedAtGTE: Time
	updatedAtLT: Time
	updatedAtLTE: Time
	"""name field predicates"""
	name: String
	nameNEQ: String
	nameIn: [String!]
	nameNotIn: [String!]
	nameGT: String
	nameGTE: String
	nameLT: String
	nameLTE: String
	nameContains: String
	nameHasPrefix: String
	nameHasSuffix: String
	nameEqualFold: String
	nameContainsFold: String
	"""ip_block edge predicates"""
	hasIPBlock: Boolean
	hasIPBlockWith: [IPBlockWhereInput!]
}
"""Return response for updateIPBlock mutation"""
type IPBlockUpdatePayload {
	"""Updated ip block type"""
	ip_block: IPBlock!
}
"""
IPBlockWhereInput is used for filtering IPBlock objects.
Input was generated by ent.
"""
input IPBlockWhereInput {
	not: IPBlockWhereInput
	and: [IPBlockWhereInput!]
	or: [IPBlockWhereInput!]
	"""id field predicates"""
	id: ID
	idNEQ: ID
	idIn: [ID!]
	idNotIn: [ID!]
	idGT: ID
	idGTE: ID
	idLT: ID
	idLTE: ID
	"""created_at field predicates"""
	createdAt: Time
	createdAtNEQ: Time
	createdAtIn: [Time!]
	createdAtNotIn: [Time!]
	createdAtGT: Time
	createdAtGTE: Time
	createdAtLT: Time
	createdAtLTE: Time
	"""updated_at field predicates"""
	updatedAt: Time
	updatedAtNEQ: Time
	updatedAtIn: [Time!]
	updatedAtNotIn: [Time!]
	updatedAtGT: Time
	updatedAtGTE: Time
	updatedAtLT: Time
	updatedAtLTE: Time
	"""prefix field predicates"""
	prefix: String
	prefixNEQ: String
	prefixIn: [String!]
	prefixNotIn: [String!]
	prefixGT: String
	prefixGTE: String
	prefixLT: String
	prefixLTE: String
	prefixContains: String
	prefixHasPrefix: String
	prefixHasSuffix: String
	prefixEqualFold: String
	prefixContainsFold: String
	"""allow_auto_subnet field predicates"""
	allowAutoSubnet: Boolean
	allowAutoSubnetNEQ: Boolean
	"""allow_auto_allocate field predicates"""
	allowAutoAllocate: Boolean
	allowAutoAllocateNEQ: Boolean
	"""ip_block_type edge predicates"""
	hasIPBlockType: Boolean
	hasIPBlockTypeWith: [IPBlockTypeWhereInput!]
	"""ip_address edge predicates"""
	hasIPAddress: Boolean
	hasIPAddressWith: [IPAddressWhereInput!]
}
"""A valid JSON string."""
scalar JSON
type Mutation {
	"""Create a new ip block type"""
	createIPAddress(
		"""Name of the ip block type"""
		input: CreateIPAddressInput!
	): IPAddressCreatePayload!
	"""Update an existing ip block type"""
	updateIPAddress(
		"""ID of the ip block type"""
		id: ID!

		"""Name of the ip block type"""
		input: UpdateIPAddressInput!
	): IPAddressUpdatePayload!
	"""Delete an existing ip block type"""
	deleteIPAddress(
		"""ID of the ip block type"""
		id: ID!
	): IPAddressDeletePayload!
	"""Create a new ip block type"""
	createIPBlock(
		"""Name of the ip block type"""
		input: CreateIPBlockInput!
	): IPBlockCreatePayload!
	"""Update an existing ip block type"""
	updateIPBlock(
		"""ID of the ip block type"""
		id: ID!

		"""Name of the ip block type"""
		input: UpdateIPBlockInput!
	): IPBlockUpdatePayload!
	"""Delete an existing ip block type"""
	deleteIPBlock(
		"""ID of the ip block type"""
		id: ID!
	): IPBlockDeletePayload!
	"""Create a new ip block type"""
	createIPBlockType(
		"""Name of the ip block type"""
		input: CreateIPBlockTypeInput!
	): IPBlockTypeCreatePayload!
	"""Update an existing ip block type"""
	updateIPBlockType(
		"""ID of the ip block type"""
		id: ID!

		"""Name of the ip block type"""
		input: UpdateIPBlockTypeInput!
	): IPBlockTypeUpdatePayload!
	"""Delete an existing ip block type"""
	deleteIPBlockType(
		"""ID of the ip block type"""
		id: ID!
	): IPBlockTypeDeletePayload!
}
"""
An object with an ID.
Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
"""
interface Node {
	"""The id of the object."""
	id: ID!
}
"""Possible directions in which to order a list of items when provided an `orderBy` argument."""
enum OrderDirection {
	"""Specifies an ascending order for a given `orderBy` argument."""
	ASC
	"""Specifies a descending order for a given `orderBy` argument."""
	DESC
}
type Owner @key(fields: "id") {
	id: ID! @external
	ip_block_type(
		"""Returns the elements in the list that come after the specified cursor."""
		after: Cursor

		"""Returns the first _n_ elements from the list."""
		first: Int

		"""Returns the elements in the list that come before the specified cursor."""
		before: Cursor

		"""Returns the last _n_ elements from the list."""
		last: Int

		"""Ordering options for IPBlockTypes returned from the connection."""
		orderBy: IPBlockTypeOrder

		"""Filtering options for IPBlockTypes returned from the connection."""
		where: IPBlockTypeWhereInput
	): IPBlockTypeConnection! @goField(forceResolver: true)
}
"""
Information about pagination in a connection.
https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
"""
type PageInfo @shareable {
	"""When paginating forwards, are there more items?"""
	hasNextPage: Boolean!
	"""When paginating backwards, are there more items?"""
	hasPreviousPage: Boolean!
	"""When paginating backwards, the cursor to continue."""
	startCursor: Cursor
	"""When paginating forwards, the cursor to continue."""
	endCursor: Cursor
}
type Query {
	"""Look up ip block type by ID"""
	ip_address(
		"""ID of the ip block type"""
		id: ID!
	): IPAddress!
	"""Look up ip block type by ID"""
	ip_block(
		"""ID of the ip block type"""
		id: ID!
	): IPBlock!
	"""Look up ip block type by ID"""
	ip_block_type(
		"""ID of the ip block type"""
		id: ID!
	): IPBlockType!
	_entities(representations: [_Any!]!): [_Entity]!
	_service: _Service!
}
"""The builtin Time type"""
scalar Time
"""Update an existing ip address type node."""
input UpdateIPAddressInput {
	"""The ip address."""
	ip: String
	"""Reserve the IP without it being assigned."""
	reserved: Boolean
}
"""Update an existing ip block type node."""
input UpdateIPBlockInput {
	"""The prefix of the ip block."""
	prefix: String
	"""Allow carving this block into smaller subnets."""
	allowAutoSubnet: Boolean
	"""Allow automatically assigning IPs directly from this block."""
	allowAutoAllocate: Boolean
}
"""Update an existing ip block type node."""
input UpdateIPBlockTypeInput {
	"""The name of the ip block type."""
	name: String
}
union _Entity = IPAddress | IPBlock | IPBlockType | Owner
type _Service {
	sdl: String
}
scalar _Any
scalar FieldSet
directive @requires(fields: FieldSet!) on FIELD_DEFINITION
directive @provides(fields: FieldSet!) on FIELD_DEFINITION
directive @extends on OBJECT | INTERFACE
directive @key(fields: FieldSet!, resolvable: Boolean = true) repeatable on OBJECT | INTERFACE
directive @link(import: [String!], url: String!) repeatable on SCHEMA
directive @external on FIELD_DEFINITION | OBJECT
directive @shareable on OBJECT | FIELD_DEFINITION
directive @tag(name: String!) repeatable on FIELD_DEFINITION | INTERFACE | OBJECT | UNION | ARGUMENT_DEFINITION | SCALAR | ENUM | ENUM_VALUE | INPUT_OBJECT | INPUT_FIELD_DEFINITION
directive @override(from: String!) on FIELD_DEFINITION
directive @inaccessible on SCALAR | OBJECT | FIELD_DEFINITION | ARGUMENT_DEFINITION | INTERFACE | UNION | ENUM | ENUM_VALUE | INPUT_OBJECT | INPUT_FIELD_DEFINITION
#directive @interfaceObject on OBJECT
extend schema
  @link(
	url: "https://specs.apollo.dev/federation/v2.3"
	import: [
	  "@key",
	  "@external",
	  "@shareable",
	  "@tag",
	  "@override",
	  "@inaccessible",
	  "@interfaceObject"
	  ]
  )
